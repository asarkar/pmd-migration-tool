package org.abhijitsarkar.kotlin.pmd

import com.xenomachina.argparser.ArgParser
import com.xenomachina.argparser.default
import com.xenomachina.argparser.mainBody
import net.sourceforge.pmd.Ruleset
import java.io.PrintWriter
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.StandardOpenOption.CREATE
import java.nio.file.StandardOpenOption.TRUNCATE_EXISTING
import java.nio.file.StandardOpenOption.WRITE
import javax.xml.bind.JAXBContext
import javax.xml.bind.Marshaller
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult

/**
 * @author Abhijit Sarkar
 */

private var verbose: Boolean = false

val isVerbose get() = verbose

class CmdLineArgs(parser: ArgParser) {
    val force by parser.flagging(
            "-f", "--force",
            help = "overwrite output file if exists, default false"
    )
    val skipValidation by parser.flagging(
            "-x", "--skip-validation",
            help = "skip validation of generated ruleset, default false"
    )
    val verbose by parser.flagging(
            "-v", "--verbose",
            help = "enable verbose mode, default false"
    )
            .default(true)
    val output by parser.storing(
            "-o", "--output",
            help = "output file path, default stdout"
    ) { Paths.get(this) }
            .default {
                null
            }
    val ruleset: Path by parser.positional("ruleset path") { Paths.get(this) }
}

fun unmarshal(ruleset: Path): Ruleset {
    return JAXBContext.newInstance(Ruleset::class.java)
            .createUnmarshaller()
            .unmarshal(ruleset.toFile())
            .let { it as Ruleset }
}

fun String.isNotMigrated() = this.startsWith("rulesets")

fun main(args: Array<String>): Unit = mainBody {
    val cmdLineArgs = ArgParser(args).parseInto(::CmdLineArgs)
    verbose = cmdLineArgs.verbose

    val out = cmdLineArgs.output?.let {
        it.apply {
            if (Files.exists(this) && !cmdLineArgs.force) {
                throw IllegalArgumentException("Output file already exists.")
            }

            if (Files.isDirectory(this)) {
                throw IllegalArgumentException("Output file is a directory.")
            }
        }
                .run { Files.newBufferedWriter(this, StandardCharsets.UTF_8, CREATE, TRUNCATE_EXISTING, WRITE) }
    } ?: PrintWriter(System.out)

    val input = cmdLineArgs.ruleset.let {
        it.apply {
            if (!Files.exists(this) || !Files.isReadable(this)) {
                throw IllegalArgumentException("Input file doesn't exist or isn't readable.")
            }

            if (Files.isDirectory(this)) {
                throw IllegalArgumentException("Input file is a directory.")
            }
        }
                .run { unmarshal(this) }
    }

    try {
        val ruleset = Migrator.migrate(input).apply {
            if (!cmdLineArgs.skipValidation) {
                RulesetValidator.validate(input, this)
            }
        }

        val doc = DocumentBuilderFactory.newInstance()
                .apply {
                    isNamespaceAware = true
                    isValidating = true
                }
                .run { newDocumentBuilder() }
                .run { newDocument() }

        JAXBContext.newInstance(Ruleset::class.java)
                .createMarshaller()
                .apply {
                    setProperty(Marshaller.JAXB_SCHEMA_LOCATION, "http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd")
                }
                .marshal(ruleset, doc)

        TransformerFactory.newInstance()
                .run {
                    newTransformer().apply {
                        setOutputProperty(OutputKeys.INDENT, "yes")
                        setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2")
                        setOutputProperty(OutputKeys.ENCODING, StandardCharsets.UTF_8.name())
                        setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "no")
                    }
                }
                .apply {
                    val result = StreamResult(out)

                    transform(DOMSource(), result)
                    setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes")

                    val comment1 = doc.createComment("This file has been generated by the pmd-migration tool")
                    val comment2 = doc.createComment("https://github.com/asarkar/pmd-migration-tool")

                    transform(DOMSource(comment1), result)
                    transform(DOMSource(comment2), result)
                    transform(DOMSource(doc), result)
                }
    } finally {
        cmdLineArgs.output?.also {
            out.close()
        }
    }
}